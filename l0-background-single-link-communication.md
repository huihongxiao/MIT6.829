# L0-Background: Single-Link Communication

英文原文：[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-829-computer-networks-fall-2002/lecture-notes/L0singlelink.pdf](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-829-computer-networks-fall-2002/lecture-notes/L0singlelink.pdf)

## Overview

这一篇笔记介绍的是课程背景，对应的内容在课程中不会介绍。在这一篇中，我们会考虑将两台计算机用相同的通讯介质连接起来并尝试在它们之间交换数据时会出现的问题。我们会先从P2P连接开始介绍，在P2P连接中唯一出现的电脑就是线路两端的电脑。之后我们会介绍共享传输介质，例如以太网。这一篇的内容在传统的网络分层的中属于Layer 2，也就是链路层。同时，这篇笔记也会涉及Layer 1，也就是物理层。

## 1. 问题

我们来看一个似乎很简单的场景：将两台计算机连在一起，并且使得它们彼此之间进行“交谈”。我们会发现这个场景并不是它看起来的那么简单。

之后，我们会系统的将这个场景转换成五个问题，并一个一个的解决这些问题。最后我们会看如何将这些问题组合在一起。

1. 第一个需要考虑的问题是：物理介质质（例如电话线，线缆或者以太网）实际传输的是模拟信号，而不是比特位（注，也就是数字信号）。因此，我们需要有一种方法来在发送端将数字信号转换成模拟信号，这种行为通常被称为调制（modulation）。对应的，在接收端将模拟信号转换成数字信号的行为被称为解调（demodulation）。在网络的物理层完成的众多事情当中，**调制解调**是一个重要的步骤。
2. 但是我们真正想做的事情是将一个大文件从一个计算机传递到另一个计算机。假设我们已经解决了调制解调的问题，也就是说我们知道如何在物理介质发送数字信号，我们还需要方法能够将文件拆分打包，并有效的发送出去。一种方式是将文件传输看成是bit流，并且持续不断的传输bit。另一种方法是将文件的内容拆分成更小的包，并且传输这些包。第二种方式就是**分包（framing）**问题。
3. 物理上的定律使得在任何情况下都无法达到无噪音通讯。所以在很多场景下，我们都关心接收者是否完整精确的收到了发送者的数据。这意味着接收端需要机制来进行**错误探测**（error detection）。
4. 在某些场景下，接收端可以探测出错误并且直接丢弃相应的数据块。然而，在很多场景下，仅仅是探测到错误是不够的，从错误中恢复也很重要。这就是**错误修正或者错误恢复**问题。
5. 最后，很多物理介质，比如以太网，可以连接超过2台计算机。所以我们还需要考虑物理介质的共享。这是**media access（**注，MAC地址全称就是Media Access Control**）**或者channel access问题，它会决定在任何时刻，谁可以发送数据，以及当channel中发生竞争时，如何仲裁和解决。

## 2. 调制&解调

### 方案1-NRZ

在最简单的调制方案中，bit “1”会被当做高电平发送，而bit “0”会被当做低电平发送。尽管名字“Non-Return to Zero”（NRZ）让人很不解，但是它是用来描述这种方案。NRZ的主要问题是，连续的相同bit（对应相同的电平），会使得接收端难以区分。举个例子，很难区分bit “0”和无信号（注，无信号的时候也是低电平）；太多连续的bit “1”，会使得信号电平偏离真实的平均值。

大多数的调制解调方案都有一个关键的需求，那就是可以容易的实现clock recovery。因为发送端会将信息（也就是bit位）通过时钟周期的触发发送出来，clock recovery是指接收端能够推断（或者是恢复）发送端的时钟频率（注，这样就可以通过发送端的时钟频率判断是否有bit “0”，以及bit “0”有几个）。直观上来看，如果有频繁的0-1和1-0的转变，clock recovery将会很容易。

![](<.gitbook/assets/image (2).png>)

### 方案2-NRZI

NRZI全称是Non-Return to Zero Inverted。这里发送端在发送bit “0”时，保持电平不变，发送bit “1”时会变化电平。当然，这里并没有解决连续bit “0”的问题，但是却解决了连续bit “1”的问题。

### 方案3-Manchester编码

Manchester编码中，发送方在发送bit “0”时，会将电平从低变高；发送bit “1”时，会将电平从高变低。这样就确保了每个bit为都有一次电平的变化，使得clock recovery可以实现。虽然它解决了上面提到的NRZ问题，但是它在某种程度上效率比较低（注，速率需要收发双方协商，且最高只能按照接收端的内部时钟频率的一半来传输，因为这样接收端才能识别出每个bit的电平变化）。

![](<.gitbook/assets/image (4).png>)

### 方案4-4B/5B

这个方案通过在传输数据中加入额外的bit，来阻止长的连续bit “0”和连续bit “1”，从而解决了Manchester编码低效率的问题。你可以认为它为数据增加了一些冗余，这样clock recovery就容易实现了。具体来说，它将每4个连续的数据bit转换成了5个bit，之后通过NRZI将其编码。这样可以确保经过编码之后，不会出现大于等于3个连续的bit “0”（注，4B编码不是简单的在4个数据bit之后增加一个bit，而是将4个数据bit映射成一个最多只有2个连续bit “0”的5bit数，详见[参考](https://erg.abdn.ac.uk/users/gorry/course/phy-pages/4b5b.html)），这样就解决了NRZI的问题。

## 3. Framing

Framing协议的一些例子是PPP（the Point to Point Protocol）和HDLC（High-level Data Link Control）。这里的思路是，发送端通过一个起始标志（HDLC协议中是一个众所周知的8bit 01111110）来区分发送的bit序列，起始标志之间的数据bit被称为一个帧（Frame）。链路层之后会通过上面介绍的一种调制方式，将Frame发送给接收端。在接收端，链路层需要接收这些Frame，并将它们传输给发送端应用程序想要交互的本地应用程序。

简单来看，每个网络协议层都包含三个接口：

1. Peer Interface：与对端进行通讯的接口
2. Lower-layer interface：在发送端向这个接口发送数据，在接收端从这个接口接收数据
3. Higher-layer interface：与Lower-layer interface相反

这里的后两个接口通常被称为服务接口（service interface）。

上面提到的分包方式中，有一个问题是起始标志有可能出现在实际传输的数据中。如果不做处理的话，这会使得接收端向更高协议层传输错误的数据。这个问题的解决方法是bit stuffing，这种方法非常像转义序列（escape sequence）。在HDLC和PPP的场景下，发送端会在数据中每5个连续的bit “1”后面加一个额外的bit “0”。在接收端，现在会使用如下的解码策略：如果看到了5个连续的bit “1”，那么再看之后的一个bit。如果这个bit是0，那么这是被填充的bit，接收端会去除这个bit “0”并继续处理。如果这个bit是1，那么这是一个下一个frame的起始标志。

HDLC和PPP使用的这种形式的分包方式被称为面向bit的分包。这种方法的一个问题是经过填充bit的frame长度是不固定的，它的具体长度取决于实际的数据内容。

## 4. 错误探测

在数据传输中有很多方法可以用来探测错误，按照复杂程度排序的话包括了奇偶校验，校验和，和CRC。错误探测的挑战在于做好探测的同时，引入尽可能少的额外负担。

## 5. 错误恢复

在有噪音或者易丢失数据的通道里面，有两种形式的错误恢复：

1. ARQ(Automatic Repeat reQuest)：ARQ通过接收端的某种确认来进行重传。TCP就是一种ARQ的实现。
2. FEC(Forward Error Correction)：基于编码学来将一些冗余的数据加到传输数据中，从而使得接收端可以修正某些特定的常见错误。本课程中并不会学习特定的FEC方法。

### 5.1 ARQ

最简单的错误恢复方法就是通过确认重传。发送端发送一个包（或者帧），之后等待来自接收端的确认。在收到确认之后再发送下一个包。如果在一定的时间内没有收到确认，那么发送端就假设包数据破损了或者包在传输中被丢弃了，并且会重传包。这种简单的方法被称为stop-and-wait。

你可能会认为，对于stop-and-wait方法，并不需要在包头部添加任何信息，因为任何时间点，最多只可能有一个包在传输。但这是错误的，因为发送端并不能确认一个自己认为丢失了的包是不是真的丢失（或者数据破损）了。

> 通常来说，发送端和接收端在一个易于出错的网络中不能达成真正的同步。这是著名的“Two generals problem”，它是指在一个山谷的两端，分别有两位将军想要通过骑马的士兵在山谷内传递消息，来商定一个相同的时间以进攻位于同一个山谷内的敌人。这里的消息是易于丢失的，因为不走运的士兵会被山谷内的敌人消灭或者扣押。可以通过反证法来证明这里的特性。假设存在一种最精简的协议可以解决这个问题，那么这个协议中的最后一条消息其实是多余的，因为它其实可能被丢失。如果这条消息是多余的，那么这与我们所做的最精简的协议是矛盾的，因此假设不成立。

例如，数据包可能只是因为某种原因被阻塞超过了约定的超时时间。这意味着ARQ需要一个序列号来使得接收端能区分重复的包。

stop-and-wait的主要缺点是：它只允许在一个RTT（Round Trip Time）内发送一个包，这使得最大的传输速率是包长度除以RTT。也就是说，它并不能填满发送端和接收端之间的通道。

那么发送端和接收端之间的通道最多能有多少数据呢？假设我们知道通道的带宽是B，RTT是d，这里的数据量是P。当通道被填满时，B会被完全利用，同时我们也知道通道内的未被确认的字节数是P时，没有数据丢失，接收端可以观察到的吞吐是P/d。
